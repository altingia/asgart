/* automatically generated by rust-bindgen */

#![allow(dead_code,
         non_camel_case_types,
         non_upper_case_globals,
         non_snake_case)]

use super::utils;

pub type int8_t = i8;
pub type int16_t = i16;
pub type int32_t = i32;
pub type int64_t = i64;
pub type uint8_t = u8;
pub type uint16_t = u16;
pub type uint32_t = u32;
pub type uint64_t = u64;
pub type int_least8_t = ::std::os::raw::c_char;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_char;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intptr_t = isize;
pub type uintptr_t = usize;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
impl ::std::default::Default for imaxdiv_t {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}
pub type sauchar_t = uint8_t;
pub type saint_t = int32_t;
pub type saidx_t = int32_t;
#[link(name = "divsufsort",
       kind = "dylib")]
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
    pub fn strtoimax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> intmax_t;
    pub fn strtoumax(__nptr: *const ::std::os::raw::c_char,
                     __endptr: *mut *mut ::std::os::raw::c_char,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
    pub fn wcstoimax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> intmax_t;
    pub fn wcstoumax(__nptr: *const __gwchar_t,
                     __endptr: *mut *mut __gwchar_t,
                     __base: ::std::os::raw::c_int) -> uintmax_t;
    pub fn divsufsort(T: *const sauchar_t, SA: *mut saidx_t, n: saidx_t)
     -> saint_t;
    pub fn divbwt(T: *const sauchar_t, U: *mut sauchar_t, A: *mut saidx_t,
                  n: saidx_t) -> saidx_t;
    pub fn divsufsort_version() -> *const ::std::os::raw::c_char;
    pub fn bw_transform(T: *const sauchar_t, U: *mut sauchar_t,
                        SA: *mut saidx_t, n: saidx_t, idx: *mut saidx_t)
     -> saint_t;
    pub fn inverse_bw_transform(T: *const sauchar_t, U: *mut sauchar_t,
                                A: *mut saidx_t, n: saidx_t, idx: saidx_t)
     -> saint_t;
    pub fn sufcheck(T: *const sauchar_t, SA: *const saidx_t, n: saidx_t,
                    verbose: saint_t) -> saint_t;
    pub fn sa_search(T: *const sauchar_t, Tsize: saidx_t, P: *const sauchar_t,
                     Psize: saidx_t, SA: *const saidx_t, SAsize: saidx_t,
                     left: *mut saidx_t) -> saidx_t;
    pub fn sa_simplesearch(T: *const sauchar_t, Tsize: saidx_t,
                           SA: *const saidx_t, SAsize: saidx_t, c: saint_t,
                           left: *mut saidx_t) -> saidx_t;
}

pub fn r_sa_search(dna: &[u8], sa: &[saidx_t], pattern: &[u8]) -> Vec<utils::Segment> {
    let mut out = 0;
    let count;
    unsafe {
        count = sa_search(dna.as_ptr(), dna.len() as i32,
            pattern.as_ptr(), pattern.len() as i32,
            sa.as_ptr(), sa.len() as i32, &mut out);
    }
    let mut rr = Vec::new();
    for i in 0..count {
        let start = sa[(out+i) as usize] as usize;
        rr.push(utils::Segment{tag: 0, start: start, end: start + pattern.len()});
    }
    rr
}


pub fn r_divsufsort(dna: &[u8]) -> Vec<saidx_t> {
    let mut sa = Vec::with_capacity(dna.len());
    sa.resize(dna.len(), 0);
    unsafe {
        divsufsort(dna.as_ptr(), sa.as_mut_ptr(), dna.len() as i32);
    }
    sa
}
